#TGA File Format Decoder
**Декодер формата Truevision Targa для использования в Qt-приложениях.**
Библиотека сильно завязана на Qt, т.к. создавалась с прицелом на использование именно в этом фреймворке. STL-вариант будет доступен позже - находится в процессе разработки.
Причиной создания стало отсутствие поддержки TGA в Qt6 на платформе Windows.
Существующие сторонние библиотеки также не отвечали моим требованиям : неполная поддержка формата, невозможность работы с байтовым буфером, отсутствие совместимости с Qt, устаревший код и т.д.

На данный момент формату уже около 40 лет. Тем не менее он до сих пор используется, например, в игровой индустрии для хранения текстур.
Формат поддерживает RLE - это самый элементарный алгоритм сжатия без потерь на основе кодирования повторяющихся пикселов.
Возможно хранение и без сжатия : такой вариант одновременно является, как слабой, так и сильной стороной формата.
Слабой - слишком большой размер. Сильной - данные уже фактически раскодированы, зачастую их достаточно поместить в память "как-есть" и
передать указателем в OpenGL или ещё в какой-либо SDK/API. Кроме этого поддерживается прозрачность через альфа-канал, что тоже важно в играх.

При создании было выработано несколько правил работы с классом GIA_TgaDecoder :
- принимает от вас не путь к файлу, а указатель на предварительно считанный в память файл, поэтому очень рекомендуется использовать memory-mapping, это упрощает работу и даёт вам свободу действий
- работает по принципу простейшего автомата конечных состояний (FSM), что в данном случе означает жёстко обозначенную последовательность вызова методов
- результатом работы всегда является буфер раскодированных данных с порядком байтов QImage::Format_RGBA8888, на основе которого можно создать объект класса QImage или QPixmap
- указатель на исходные данные должен быть валидным на всё время использования объекта GIA_TgaDecoder

Библиотека тестировалась только на Intel-архитектуре с порядком байтов little-endian. На архитектурах типа big-endian правильность работы не гарантируется : могут быть неверно интерпретированы
значения RGB, т.к. которые методы класса манипулируют не байтами, а двойными словами. Я всегда готов внести коррективы, если найдётся тестировщик с платформой, отличной от Intel.

Надо сказать, что сам по себе формат хранит данные в порядке little-endian. Это связано с историей его возникновения. TGA создавался как собственный формат плат видеозахвата для платформы IBM PC.

##Поддерживаемые типы
В заголовке TGA есть поле, указывающее каким образом пиксельные данные хранятся внутри файла.
Существует разница между разрядностью пиксела изображения и разрядностью цвета в цветовой таблице.
Пиксел может кодироваться, например, 8 битами, и эти данные будут лишь индексом в цветовой таблице, которая, в свою очередь, может содержать цвета практически любой разрадности (например 24 или 32-бит).
Приэтом эти же 8 бит можно использовать в монохромном изображении (aka в градациях серого) для непосредственного кодирования цвета, т.е. без всяких ссылок на цветовую таблицу.
Кроме того доступно сжатие RLE, что порождает ещё больше вариантов. 

###Чтобы разделять виды кодирования разработчики формата TGA ввели типы :

|Тип TGA|Цветовая таблица|Кодирование|Поддержка библиотекой|
|--|--|--|--|
|1|Есть|Нет|Пока только 24 и 32-битные цветовые таблицы. Разрядность пиксела 8-бит.|














